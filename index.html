<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pacman Clone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #111;
            --text-color: #fff;
            --accent-color: #ffd700;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            /* 禁止手机上的长按选中文字 */
            user-select: none; 
            -webkit-user-select: none;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden; /* 防止页面滚动 */
            touch-action: none; /* 关键：禁止浏览器默认的滑动行为 */
        }
        #game-container {
            position: relative;
            border: 4px solid #222;
            padding: 10px;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            /* 2. 容器适配：最大宽度不超过屏幕 */
            max-width: 98vw;
            max-height: 98vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #score-board {
            margin-bottom: 10px;
            font-size: 16px; /* 稍微调小一点字体适配手机 */
            color: var(--text-color);
            text-align: left;
            width: 100%;
        }
        canvas {
            display: block;
            background-color: #000;
            border: 2px solid #1919a6;
            /* 3. 画布适配：让 Canvas 自动缩放 */
            width: 100%;
            height: auto;
            max-width: 100%;
            /* 保持像素清晰度 */
            image-rendering: pixelated; 
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px; /* 手机上字体改小一点 */
            font-weight: bold;
            color: var(--accent-color);
            text-align: center;
            text-shadow: 4px 4px #000;
            display: none;
            z-index: 10;
            width: 90%; /* 防止文字换行太难看 */
            line-height: 1.5;
        }
        #message.visible {
            display: block;
        }
        
        /* 针对大屏幕稍微放大一点字体 */
        @media (min-width: 600px) {
            #message { font-size: 48px; }
            #score-board { font-size: 20px; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-board">
            <span>SCORE: <span id="score">0</span></span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="message">TAP TO START</div>
    </div>
    <script>
        // --- 1. TileMap Class ---
        class TileMap {
            constructor(tileSize) {
                this.tileSize = tileSize;
                this.reset();
            }
            reset() {
                // 21x21 Map
                this.map = [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                    [1, 3, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 3, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 2, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                    [1, 3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 1],
                    [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1],
                    [1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ];
            }
            draw(ctx) {
                for (let row = 0; row < this.map.length; row++) {
                    for (let col = 0; col < this.map[row].length; col++) {
                        let tile = this.map[row][col];
                        let x = col * this.tileSize;
                        let y = row * this.tileSize;
                        if (tile === 1) {
                            this.drawWall(ctx, x, y, this.tileSize);
                        } else if (tile === 0) {
                            this.drawDot(ctx, x, y, this.tileSize);
                        } else if (tile === 3) {
                            this.drawPowerPellet(ctx, x, y, this.tileSize);
                        }
                    }
                }
            }
            drawWall(ctx, x, y, size) {
                ctx.fillStyle = '#1919a6';
                ctx.fillRect(x, y, size, size);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, size, size);
            }
            drawDot(ctx, x, y, size) {
                ctx.fillStyle = '#ffb8ae';
                const dotSize = size / 5;
                const offset = (size - dotSize) / 2;
                ctx.fillRect(x + offset, y + offset, dotSize, dotSize);
            }
            drawPowerPellet(ctx, x, y, size) {
                ctx.fillStyle = '#ffb8ae';
                const dotSize = size / 2;
                const offset = (size - dotSize) / 2;
                ctx.beginPath();
                ctx.arc(x + size / 2, y + size / 2, dotSize / 2, 0, Math.PI * 2);
                ctx.fill();
            }
            didWin() {
                return this.dotsLeft() === 0;
            }
            dotsLeft() {
                return this.map.flat().filter(tile => tile === 0 || tile === 3).length;
            }
            getPacmanSpawn() {
                for (let row = 0; row < this.map.length; row++) {
                    for (let col = 0; col < this.map[row].length; col++) {
                        if (this.map[row][col] === 2) return { x: col, y: row };
                    }
                }
                return { x: 10, y: 15 };
            }
            getGhostSpawns() {
                const spawns = [];
                for (let row = 0; row < this.map.length; row++) {
                    for (let col = 0; col < this.map[row].length; col++) {
                        if (this.map[row][col] === 4) spawns.push({ x: col, y: row });
                    }
                }
                return spawns;
            }
            isWall(row, col) {
                if (row < 0 || row >= this.map.length || col < 0 || col >= this.map[0].length) {
                    return true;
                }
                return this.map[row][col] === 1;
            }
            eatDot(row, col) {
                if (this.map[row][col] === 0 || this.map[row][col] === 3) {
                    const isPower = this.map[row][col] === 3;
                    this.map[row][col] = 5;
                    return isPower ? 'power' : 'dot';
                }
                return null;
            }
        }
        // --- 2. Pacman Class ---
        class Pacman {
            constructor(tileSize, tileMap) {
                this.tileSize = tileSize;
                this.tileMap = tileMap;
                this.reset();
                this.requestedNextDirection = null;
                this.currentDirection = null;
                document.addEventListener('keydown', this.keydown);
            }
            keydown = (e) => {
                if (e.code === 'ArrowUp' || e.code === 'KeyW') this.requestedNextDirection = 3;
                if (e.code === 'ArrowDown' || e.code === 'KeyS') this.requestedNextDirection = 1;
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') this.requestedNextDirection = 2;
                if (e.code === 'ArrowRight' || e.code === 'KeyD') this.requestedNextDirection = 0;
            }
            // 新增：供外部调用的方向设置方法
            setDirection(dir) {
                this.requestedNextDirection = dir;
            }
            reset() {
                const spawn = this.tileMap.getPacmanSpawn();
                this.x = spawn.x * this.tileSize;
                this.y = spawn.y * this.tileSize;
                this.velocity = 2;
                this.currentDirection = 0;
                this.requestedNextDirection = 0;
                this.mouthOpen = 0;
                this.mouthSpeed = 0.2;
            }
            update(ghosts) {
                if (this.requestedNextDirection !== null) {
                    if (this.canMove(this.requestedNextDirection)) {
                        this.currentDirection = this.requestedNextDirection;
                        this.requestedNextDirection = null;
                    }
                }
                if (this.canMove(this.currentDirection)) {
                    switch (this.currentDirection) {
                        case 0: this.x += this.velocity; break;
                        case 1: this.y += this.velocity; break;
                        case 2: this.x -= this.velocity; break;
                        case 3: this.y -= this.velocity; break;
                    }
                }
                this.mouthOpen += this.mouthSpeed;
                if (this.mouthOpen > 0.8 || this.mouthOpen < 0) {
                    this.mouthSpeed = -this.mouthSpeed;
                }
                this.checkEat();
            }
            canMove(direction) {
                let nextX = this.x;
                let nextY = this.y;
                if (direction === 0) nextX += this.velocity;
                if (direction === 1) nextY += this.velocity;
                if (direction === 2) nextX -= this.velocity;
                if (direction === 3) nextY -= this.velocity;
                const margin = 1;
                const left = nextX + margin;
                const right = nextX + this.tileSize - margin;
                const top = nextY + margin;
                const bottom = nextY + this.tileSize - margin;
                const corners = [
                    { c: Math.floor(left / this.tileSize), r: Math.floor(top / this.tileSize) },
                    { c: Math.floor(right / this.tileSize), r: Math.floor(top / this.tileSize) },
                    { c: Math.floor(left / this.tileSize), r: Math.floor(bottom / this.tileSize) },
                    { c: Math.floor(right / this.tileSize), r: Math.floor(bottom / this.tileSize) }
                ];
                for (const pt of corners) {
                    if (this.tileMap.isWall(pt.r, pt.c)) return false;
                }
                return true;
            }
            checkEat() {
                const center = {
                    x: this.x + this.tileSize / 2,
                    y: this.tileSize / 2 + this.y
                };
                const row = Math.floor(center.y / this.tileSize);
                const col = Math.floor(center.x / this.tileSize);
                const result = this.tileMap.eatDot(row, col);
                if (result === 'dot') {
                    const event = new CustomEvent('score', { detail: 10 });
                    document.dispatchEvent(event);
                } else if (result === 'power') {
                    const event = new CustomEvent('power', { detail: 50 });
                    document.dispatchEvent(event);
                }
            }
            draw(ctx) {
                const halfSize = this.tileSize / 2;
                const x = this.x + halfSize;
                const y = this.y + halfSize;
                ctx.save();
                ctx.translate(x, y);
                const rotation = this.currentDirection * 90 * (Math.PI / 180);
                ctx.rotate(rotation);
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                const angle = 0.2 * Math.PI * (0.5 + 0.5 * Math.sin(this.mouthOpen * Math.PI));
                ctx.arc(0, 0, halfSize - 2, angle, 2 * Math.PI - angle);
                ctx.lineTo(0, 0);
                ctx.fill();
                ctx.restore();
            }
        }
        // --- 3. Ghost Class ---
        class Ghost {
            constructor(tileSize, tileMap, color, startX, startY) {
                this.tileSize = tileSize;
                this.tileMap = tileMap;
                this.color = color;
                this.startX = startX;
                this.startY = startY;
                if (this.startX === undefined) this.startX = 10;
                if (this.startY === undefined) this.startY = 10;
                this.reset();
            }
            reset() {
                this.x = this.startX * this.tileSize;
                this.y = this.startY * this.tileSize;
                this.velocity = 1;
                this.direction = 2;
                this.scared = false;
                this.scaredTimer = 0;
                this.dead = false;
                this.respawnTimer = 0;
                this.x = Math.round(this.x);
                this.y = Math.round(this.y);
            }
            die() {
                this.dead = true;
                this.respawnTimer = 180;
                this.x = -1000;
                this.y = -1000;
                this.scared = false;
            }
            update(pacman) {
                if (this.dead) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) {
                        this.reset();
                    }
                    return;
                }
                const remainderX = this.x % this.tileSize;
                const remainderY = this.y % this.tileSize;
                const onGrid = (Math.abs(remainderX) < 0.1) && (Math.abs(remainderY) < 0.1);
                if (onGrid) {
                    this.x = Math.round(this.x / this.tileSize) * this.tileSize;
                    this.y = Math.round(this.y / this.tileSize) * this.tileSize;
                    this.chooseDirection(pacman);
                }
                switch (this.direction) {
                    case 0: this.x += this.velocity; break;
                    case 1: this.y += this.velocity; break;
                    case 2: this.x -= this.velocity; break;
                    case 3: this.y -= this.velocity; break;
                }
                if (this.x < -this.tileSize || this.x > this.tileMap.map[0].length * this.tileSize ||
                    this.y < -this.tileSize || this.y > this.tileMap.map.length * this.tileSize) {
                    this.reset();
                }
                if (this.scared) {
                    this.scaredTimer--;
                    if (this.scaredTimer <= 0) {
                        this.scared = false;
                        this.velocity = 1;
                    }
                }
            }
            chooseDirection(pacman) {
                const moves = [];
                const gridX = Math.round(this.x / this.tileSize);
                const gridY = Math.round(this.y / this.tileSize);
                if (!this.tileMap.isWall(gridY, gridX + 1)) moves.push(0);
                if (!this.tileMap.isWall(gridY + 1, gridX)) moves.push(1);
                if (!this.tileMap.isWall(gridY, gridX - 1)) moves.push(2);
                if (!this.tileMap.isWall(gridY - 1, gridX)) moves.push(3);
                const reverse = (this.direction + 2) % 4;
                const forwardMoves = moves.filter(m => m !== reverse);
                let possibleMoves = forwardMoves.length > 0 ? forwardMoves : moves;
                if (possibleMoves.length === 0) {
                    this.direction = reverse;
                    return;
                }
                if (this.scared) {
                    this.direction = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                } else {
                    let bestMove = possibleMoves[0];
                    let minDist = Infinity;
                    const pacGridX = Math.round(pacman.x / this.tileSize);
                    const pacGridY = Math.round(pacman.y / this.tileSize);
                    possibleMoves.forEach(move => {
                        let nextX = gridX + (move === 0 ? 1 : (move === 2 ? -1 : 0));
                        let nextY = gridY + (move === 1 ? 1 : (move === 3 ? -1 : 0));
                        const dist = Math.abs(nextX - pacGridX) + Math.abs(nextY - pacGridY);
                        if (dist < minDist) {
                            minDist = dist;
                            bestMove = move;
                        }
                    });
                    this.direction = bestMove;
                }
            }
            makeScared() {
                if (this.dead) return;
                if (!this.scared) {
                    this.direction = (this.direction + 2) % 4;
                }
                this.scared = true;
                this.scaredTimer = 600;
                this.velocity = 0.5;
            }
            draw(ctx) {
                const x = this.x;
                const y = this.y;
                ctx.fillStyle = this.scared ? 'blue' : this.color;
                ctx.beginPath();
                ctx.arc(x + this.tileSize / 2, y + this.tileSize / 2 - 2, this.tileSize / 2 - 2, Math.PI, 0);
                ctx.lineTo(x + this.tileSize - 2, y + this.tileSize - 2);
                ctx.lineTo(x + 2, y + this.tileSize - 2);
                ctx.fill();
                if (!this.scared) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(x + this.tileSize * 0.35, y + this.tileSize * 0.4, 4, 0, Math.PI * 2);
                    ctx.arc(x + this.tileSize * 0.65, y + this.tileSize * 0.4, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(x + this.tileSize * 0.35, y + this.tileSize * 0.4, 2, 0, Math.PI * 2);
                    ctx.arc(x + this.tileSize * 0.65, y + this.tileSize * 0.4, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#ffb8ae';
                    ctx.beginPath();
                    ctx.arc(x + this.tileSize * 0.35, y + this.tileSize * 0.5, 2, 0, Math.PI * 2);
                    ctx.arc(x + this.tileSize * 0.65, y + this.tileSize * 0.5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ffb8ae';
                    ctx.beginPath();
                    ctx.moveTo(x + 6, y + 22);
                    ctx.lineTo(x + 10, y + 18);
                    ctx.lineTo(x + 14, y + 22);
                    ctx.lineTo(x + 18, y + 18);
                    ctx.lineTo(x + 22, y + 22);
                    ctx.stroke();
                }
            }
        }
        // --- 4. Game Logic & Sound ---
        const SoundManager = {
            ctx: null,
            init: function () {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            resume: function () {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function (freq, type, duration) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playStart: function () {
                this.init(); this.resume();
                this.playTone(600, 'square', 0.1);
                setTimeout(() => this.playTone(800, 'square', 0.2), 100);
            },
            playEat: function () {
                if (!this.ctx) return;
                this.playTone(400, 'sine', 0.05);
            },
            playPowerUp: function () {
                this.init(); this.resume();
                this.playTone(300, 'sawtooth', 0.1);
                setTimeout(() => this.playTone(500, 'sawtooth', 0.1), 100);
                setTimeout(() => this.playTone(800, 'sawtooth', 0.2), 200);
            },
            playDie: function () {
                this.playTone(200, 'sawtooth', 0.5);
                setTimeout(() => this.playTone(100, 'sawtooth', 0.5), 400);
            }
        };
        const TILE_SIZE = 32;
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.messageEl = document.getElementById('message');
                this.scoreEl = document.getElementById('score');
                this.tileSize = 32;
                this.tileMap = new TileMap(this.tileSize);
                this.pacman = new Pacman(this.tileSize, this.tileMap);
                this.ghosts = [];
                this.score = 0;
                this.state = 'START';
                this.startScreenTimer = 0;
                this.resizeCanvas();
                this.handleInput = this.handleInput.bind(this);
                
                // 输入监听 (包括鼠标、键盘、触摸)
                window.addEventListener('keydown', this.handleInput);
                window.addEventListener('mousedown', this.handleInput);
                window.addEventListener('touchstart', this.handleInput, {passive: false});
                
                // 触摸滑动控制逻辑
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.canvas.addEventListener('touchstart', (e) => {
                    this.touchStartX = e.changedTouches[0].screenX;
                    this.touchStartY = e.changedTouches[0].screenY;
                }, {passive: false});
                
                this.canvas.addEventListener('touchend', (e) => {
                    if (this.state !== 'PLAYING') return;
                    let endX = e.changedTouches[0].screenX;
                    let endY = e.changedTouches[0].screenY;
                    let diffX = endX - this.touchStartX;
                    let diffY = endY - this.touchStartY;
                    
                    // 防抖动：必须滑动超过30px才算
                    if (Math.abs(diffX) < 30 && Math.abs(diffY) < 30) return;
                    
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        // 横向滑动
                        this.pacman.setDirection(diffX > 0 ? 0 : 2); // 0=Right, 2=Left
                    } else {
                        // 纵向滑动
                        this.pacman.setDirection(diffY > 0 ? 1 : 3); // 1=Down, 3=Up
                    }
                }, {passive: false});

                document.addEventListener('score', (e) => {
                    this.score += e.detail;
                    this.scoreEl.innerText = this.score;
                    SoundManager.playEat();
                });
                document.addEventListener('power', (e) => {
                    this.score += e.detail;
                    this.scoreEl.innerText = this.score;
                    SoundManager.playPowerUp();
                    this.ghosts.forEach(g => g.makeScared());
                });
                this.gameLoop();
            }
            handleInput(e) {
                if (e.code === 'Space') e.preventDefault();
                // 触摸开始游戏
                if (this.state === 'START' || this.state === 'GAMEOVER' || this.state === 'WIN') {
                    if (e.type === 'mousedown' || e.code === 'Space' || e.key || e.type === 'touchstart') {
                        this.startGame();
                    }
                }
            }
            resizeCanvas() {
                this.canvas.width = this.tileMap.map[0].length * this.tileSize;
                this.canvas.height = this.tileMap.map.length * this.tileSize;
            }
            startGame() {
                SoundManager.playStart();
                this.state = 'PLAYING';
                this.score = 0;
                this.scoreEl.innerText = this.score;
                this.messageEl.classList.remove('visible');
                this.messageEl.style.display = 'none';
                this.tileMap.reset();
                this.pacman.reset();
                const spawns = this.tileMap.getGhostSpawns();
                const s1 = spawns[0] || { x: 1, y: 1 };
                const s2 = spawns[1] || { x: 19, y: 1 };
                const s3 = spawns[2] || { x: 1, y: 19 };
                const s4 = spawns[3] || { x: 19, y: 19 };
                this.ghosts = [
                    new Ghost(this.tileSize, this.tileMap, 'red', s1.x, s1.y),
                    new Ghost(this.tileSize, this.tileMap, 'pink', s2.x, s2.y),
                    new Ghost(this.tileSize, this.tileMap, 'cyan', s3.x, s3.y),
                    new Ghost(this.tileSize, this.tileMap, 'orange', s4.x, s4.y)
                ];
            }
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
            update() {
                if (this.state === 'START') {
                    this.startScreenTimer += 0.016;
                    return;
                }
                if (this.state !== 'PLAYING') return;
                this.pacman.update(this.ghosts);
                this.ghosts.forEach(ghost => ghost.update(this.pacman));
                this.checkCollisions();
                if (this.tileMap.didWin()) {
                    this.gameWin();
                }
            }
            draw() {
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.state === 'START') {
                    this.drawStartScreen();
                } else if (this.state === 'PLAYING') {
                    this.tileMap.draw(this.ctx);
                    this.pacman.draw(this.ctx);
                    this.ghosts.forEach(ghost => {
                        if (!ghost.dead) ghost.draw(this.ctx);
                    });
                }
            }
            drawStartScreen() {
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                this.ctx.fillStyle = '#ffd700';
                this.ctx.font = '40px "Press Start 2P"';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("PACMAN CLONE", cx, cy - 80);
                this.ctx.beginPath();
                const mouth = Math.abs(Math.sin(this.startScreenTimer * 5)) * 0.4;
                this.ctx.arc(cx, cy, 40, mouth, Math.PI * 2 - mouth);
                this.ctx.lineTo(cx, cy);
                this.ctx.fill();
                if (Math.floor(this.startScreenTimer * 2) % 2 === 0) {
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '20px "Press Start 2P"';
                    // 动态文字：根据是否是手机显示不同的提示
                    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
                    const startText = isMobile ? "TAP TO START" : "PRESS ANY BUTTON";
                    const subText = isMobile ? "SWIPE TO MOVE" : "TO START";
                    
                    this.ctx.fillText(startText, cx, cy + 80);
                    this.ctx.fillText(subText, cx, cy + 110);
                }
                this.ctx.fillStyle = '#666';
                this.ctx.font = '12px "Press Start 2P"';
                this.ctx.fillText("WASD / ARROWS / SWIPE", cx, this.canvas.height - 30);
            }
            checkCollisions() {
                const pacCenter = { x: this.pacman.x + 16, y: this.pacman.y + 16 };
                this.ghosts.forEach(ghost => {
                    if (ghost.dead) return;
                    const ghostCenter = { x: ghost.x + 16, y: ghost.y + 16 };
                    const dist = Math.hypot(pacCenter.x - ghostCenter.x, pacCenter.y - ghostCenter.y);
                    if (dist < 30) {
                        if (ghost.scared) {
                            this.score += 200;
                            this.scoreEl.innerText = this.score;
                            SoundManager.playEat();
                            SoundManager.playPowerUp();
                            ghost.die();
                        } else {
                            this.gameOver();
                        }
                    }
                });
            }
            gameWin() {
                this.state = 'WIN';
                this.messageEl.innerText = "YOU WIN!";
                this.messageEl.style.display = 'block';
                this.messageEl.classList.add('visible');
                SoundManager.playPowerUp();
            }
            gameOver() {
                this.state = 'GAMEOVER';
                this.messageEl.innerText = "GAME OVER";
                this.messageEl.style.display = 'block';
                this.messageEl.classList.add('visible');
                SoundManager.playDie();
            }
        }
        const game = new Game();
    </script>
</body>
</html>
